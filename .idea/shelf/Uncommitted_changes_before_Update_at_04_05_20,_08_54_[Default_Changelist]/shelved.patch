Index: project/dia_pckg/Class.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.figure import figaspect\n\nfrom project.dia_pckg.Config import features_space\nfrom project.dia_pckg.Utils import polynomial\n\n\nclass Class:\n\n    def __init__(self, class_name, class_features, product, n_abrupt_phases, seed, summary=True):\n        \"\"\"\n        :param class_name: name of the class\n        :param class_features: binary features of the class\n        :param product: Product object\n        :param n_abrupt_phases: number of abrupt phases\n        :param summary: boolean to print the summary of the informations of the class\n        \"\"\"\n        np.random.seed(seed)\n        self.name = class_name\n        self.features = class_features\n\n        self.product = product\n        self.n_abrupt_phases = n_abrupt_phases\n\n        # here we generate one conversion curve for each phase\n        self.conv_rates = [self.get_conversion_rate(self.product.base_price,\n                                                    self.product.max_price) for _ in range(self.n_abrupt_phases)]\n\n        if summary:\n            self.print_summary()\n\n    def get_conversion_rate(self, product_base_price, product_max_price, n_steps=3, polynomial_rank=10):\n        \"\"\"\n            Function to generate the conversion rate of the class\n        :param product_base_price: minimum price of the product\n        :param product_max_price: maximum price of the product\n        :param n_steps: number of intervals to keep the same convertion rate\n        :param polynomial_rank: rank of the polynomial for the approximation of the steps, to obtain a curve\n        :return: tuple containing the x-axis: prices and the y-axis: conversion rate\n        \"\"\"\n        prices = np.linspace(product_base_price, product_max_price, product_max_price - product_base_price)\n        y = np.zeros(shape=prices.shape)\n\n        steps_idx = np.sort(np.random.randint(0, prices.shape[0], n_steps)) # pylint: disable=E1136\n        last_step_idx = 0\n        last_value = 0.90\n        for step_idx in steps_idx:\n            value = np.random.uniform(last_value / 2, last_value)\n            y[last_step_idx:step_idx] = value\n            last_value = value\n            last_step_idx = step_idx\n\n        probabilities = polynomial(y, rank=polynomial_rank)\n        # using the polynomial approximation sometime the curve can oscillate near zero\n        # to avoid this problem we find the first zero and set all the next values equal to zero\n        first_zero = np.where(probabilities <= 0)[0]\n        if first_zero.shape[0] > 0:\n            probabilities[first_zero[0]:] = 0\n\n        # to rescale between 0 and 1\n        # probabilities = probabilities / np.max(probabilities)\n\n        return (np.asarray(prices), np.asarray(probabilities))\n\n    def plot_conversion_rate(self):\n        \"\"\"\n            This function plots the curves of the different abrupt phases\n        :return:\n        \"\"\"\n        w, h = figaspect(0.2)\n\n        fig, axs = plt.subplots(1, self.n_abrupt_phases, figsize=(w, h))\n        fig.suptitle(f'Conversion Curves - Class name: {self.name}', y=1.)\n\n        for n in range(self.n_abrupt_phases):\n            axs[n].set_title(f'Phase: {n + 1}')\n            axs[n].set_ylim(0, 1)\n            axs[n].plot(self.conv_rates[n][0],\n                        self.conv_rates[n][1])\n            axs[n].set_xlabel('Price')\n            axs[n].set_ylabel('Conversion Rate')\n\n        fig.show()\n\n    def print_summary(self):\n        \"\"\"\n            This function prints a summary of this class\n        :return:\n        \"\"\"\n        features_meaning = []\n        for i, bin in enumerate(self.features):\n            feat_value = features_space[list(features_space.keys())[i]][bin]\n            features_meaning.append(feat_value)\n\n        summary = f'---------------------------------\\n' \\\n                  f'Class name: {self.name}\\n' \\\n                  f'Feature values: {features_meaning}\\n' \\\n                  f'Number of abrupt phases: {self.n_abrupt_phases}\\n' \\\n                  f'---------------------------------\\n'\n        print(summary)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- project/dia_pckg/Class.py	(revision 3faa883b1d6fa6d2d9ec3a0365c72f4cece51532)
+++ project/dia_pckg/Class.py	(date 1588519163718)
@@ -42,7 +42,7 @@
         prices = np.linspace(product_base_price, product_max_price, product_max_price - product_base_price)
         y = np.zeros(shape=prices.shape)
 
-        steps_idx = np.sort(np.random.randint(0, prices.shape[0], n_steps)) # pylint: disable=E1136
+        steps_idx = np.sort(np.random.randint(0, prices.shape[0], n_steps))  # pylint: disable=E1136
         last_step_idx = 0
         last_value = 0.90
         for step_idx in steps_idx:
Index: project/part_4/TS_Learner.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from project.dia_pckg.Learner import *\n\n\nclass TS_Learner(Learner):\n    \"\"\"\n        This is the same code of the prof\n    \"\"\"\n\n    def __init__(self, n_arms):\n        \"\"\"\n        :param n_arms:\n        \"\"\"\n        super().__init__(n_arms)\n\n        self.beta_parameters = np.ones((n_arms, 2))\n\n    def pull_arm(self):\n        \"\"\"\n        :return: index of the most interesting arm from the demand point of view\n        \"\"\"\n        idx = np.argmax(\n            np.random.beta(self.beta_parameters[:, 0],\n                           self.beta_parameters[:, 1])\n        )\n        return idx\n\n    def pull_arm_v2(self, arm_prices):\n        \"\"\"\n        :return: index of the most interesting arm from the revenue point of view\n        \"\"\"\n        probabilities = np.random.beta(self.beta_parameters[:, 0],\n                           self.beta_parameters[:, 1])\n        values = probabilities * arm_prices\n        idx = np.argmax(probabilities * arm_prices)\n        return idx\n\n    def update(self, pulled_arm, reward):\n        \"\"\"\n        :param pulled_arm:\n        :param reward:\n        :return:\n        \"\"\"\n        self.t += 1\n        self.update_observations(pulled_arm, reward)\n        self.beta_parameters[pulled_arm, 0] = self.beta_parameters[pulled_arm, 0] + reward\n        self.beta_parameters[pulled_arm, 1] = self.beta_parameters[pulled_arm, 1] + 1.0 - reward\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- project/part_4/TS_Learner.py	(revision 3faa883b1d6fa6d2d9ec3a0365c72f4cece51532)
+++ project/part_4/TS_Learner.py	(date 1588519163746)
@@ -29,7 +29,7 @@
         :return: index of the most interesting arm from the revenue point of view
         """
         probabilities = np.random.beta(self.beta_parameters[:, 0],
-                           self.beta_parameters[:, 1])
+                                       self.beta_parameters[:, 1])
         values = probabilities * arm_prices
         idx = np.argmax(probabilities * arm_prices)
         return idx
Index: project/part_4/Env_4.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\n\nfrom project.dia_pckg.Environment import Environment\n\n\nclass Env_4(Environment):\n\n    def __init__(self, initial_date, n_days, users_per_day,\n                 class_1, class_2, class_3, n_arms):\n        \"\"\"\n        :param initial_date: when the campaign begins\n        :param n_days: number of days of the campaign\n        :param users_per_day: number of users per day\n        :param class_1: Class object\n        :param class_2: Class object\n        :param class_3: Class object\n        :param n_arms: number of arms of the Thomson Sampling algorithm\n        \"\"\"\n        super().__init__(initial_date, n_days)\n\n        self.round_per_day = users_per_day\n        self.count_rounds_today = 0\n\n        self.classes = [class_1, class_2, class_3]\n        self.aggregate_demand_curve = self.get_aggregate_curve()\n\n        self.n_arms = n_arms\n        # In the exercises of the prof there are fixed probabilities, but in our case\n        # we need to fix the position of the arms at a specific distance -> our candidates\n        self.arm_distance = int(self.aggregate_demand_curve[1].shape[0] / self.n_arms)\n\n    def user_step(self, pulled_arm, user):\n        \"\"\"\n            This method performs a round considering the number of steps per day\n            Only after n rounds it perform a step in the implemented class\n        :param pulled_arm: arm to pull\n        :param user: User object\n        :return: (reward, current date, done) done is a boolean -> True if the \"game\" is finished\n        \"\"\"\n        reward = self.round(pulled_arm, user)\n\n        current_date = self.get_current_date()\n        done = False\n\n        self.count_rounds_today += 1\n        if self.count_rounds_today == self.round_per_day:\n            self.count_rounds_today = 0\n            current_date, done = self.step()\n\n        return (reward, current_date, done)\n\n    def round(self, pulled_arm, user):\n        \"\"\"\n            This method performs a round taking the probability from the user's class\n        :param pulled_arm: arm to pull\n        :param user: User object\n        :return: reward\n        \"\"\"\n        # class of the user\n        conv_rate = None\n        for class_ in self.classes:\n            if user.class_name == class_.name:\n                conv_rate = class_.conv_rates[0]  # taking the first because no abrupt phases\n\n        # taking the index of the pulled arm\n        probability = conv_rate[1][pulled_arm * self.arm_distance]\n\n        reward = np.random.binomial(1, probability)\n        return reward \n\n\n\n    def reset(self):\n        \"\"\"\n            to reset the environment\n        :return: None\n        \"\"\"\n        self.count_rounds_today = 0\n        return super(Env_4, self).reset()\n\n    def get_aggregate_curve(self):\n        \"\"\"\n        :return: the aggregate curve\n        \"\"\"\n        prices = self.classes[0].conv_rates[0][0]\n\n        stack = np.stack(\n            [self.classes[0].conv_rates[0][1],\n             self.classes[1].conv_rates[0][1],\n             self.classes[2].conv_rates[0][1]], axis=1\n        )\n        aggr_proba = np.mean(stack, axis=-1)\n        return (prices, aggr_proba)\n\n    def get_optimals(self):\n        \"\"\"\n        :return: (aggregate_optimal, class_1_optimal, class_2_optimal, class_3_optimal)\n        \"\"\"\n        return (\n            self.get_optimal_price(self.aggregate_demand_curve),\n            self.get_optimal_price(self.classes[0].conv_rates[0]),\n            self.get_optimal_price(self.classes[1].conv_rates[0]),\n            self.get_optimal_price(self.classes[2].conv_rates[0]),\n        )\n\n    # [Disclaimer!]\n    # I don't know where is the best allocation for this function.\n    # I will leave it here for the moment.\n    def get_optimal_price(self, conv_rate):\n        \"\"\"\n            This method computes the max area\n        :param conv_rate: (price, probability)\n        :return:\n        \"\"\"\n        areas = conv_rate[0] * conv_rate[1]\n        idx = np.argmax(areas)\n        return (conv_rate[0][idx], conv_rate[1][idx])\n\n\n    def get_arm_price (self, arms):\n        prices = np.zeros(len(arms))\n        conv_rate = self.classes[0].conv_rates[0]\n        \n        for i in range (len(arms)):\n            idx = int(arms[i] * self.arm_distance)\n            val = conv_rate[0][idx]\n            prices[i] = val\n\n        return prices\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- project/part_4/Env_4.py	(revision 3faa883b1d6fa6d2d9ec3a0365c72f4cece51532)
+++ project/part_4/Env_4.py	(date 1588519163754)
@@ -66,10 +66,8 @@
         probability = conv_rate[1][pulled_arm * self.arm_distance]
 
         reward = np.random.binomial(1, probability)
-        return reward 
+        return reward
 
-
-
     def reset(self):
         """
             to reset the environment
@@ -116,12 +114,11 @@
         idx = np.argmax(areas)
         return (conv_rate[0][idx], conv_rate[1][idx])
 
-
-    def get_arm_price (self, arms):
+    def get_arm_price(self, arms):
         prices = np.zeros(len(arms))
         conv_rate = self.classes[0].conv_rates[0]
-        
-        for i in range (len(arms)):
+
+        for i in range(len(arms)):
             idx = int(arms[i] * self.arm_distance)
             val = conv_rate[0][idx]
             prices[i] = val
Index: project/dia_pckg/Learner.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\n\n\nclass Learner():\n    \"\"\"\n        This is the same Learner of the prof\n    \"\"\"\n\n    def __init__(self, n_arms):\n        \"\"\"\n        :param n_arms:\n        \"\"\"\n        self.n_arms = n_arms\n\n        self.t = 0\n        self.rewards_per_arm = x = [[] for _ in range(n_arms)]      \n        self.collected_rewards = np.array([])\n        self.collected_arms = np.array([])\n\n    def update_observations(self, pulled_arm, reward):\n        \"\"\"\n        :param pulled_arm:\n        :param reward:\n        :return:\n        \"\"\"\n        self.rewards_per_arm[pulled_arm].append(reward)\n        self.collected_rewards = np.append(self.collected_rewards, reward)\n        self.collected_arms = np.append(self.collected_arms, pulled_arm)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- project/dia_pckg/Learner.py	(revision 3faa883b1d6fa6d2d9ec3a0365c72f4cece51532)
+++ project/dia_pckg/Learner.py	(date 1588519163766)
@@ -13,7 +13,7 @@
         self.n_arms = n_arms
 
         self.t = 0
-        self.rewards_per_arm = x = [[] for _ in range(n_arms)]      
+        self.rewards_per_arm = x = [[] for _ in range(n_arms)]
         self.collected_rewards = np.array([])
         self.collected_arms = np.array([])
 
Index: project/part_4/Testing_Environment.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import sys\n#sys.path.insert(0, 'D:\\\\usw-andreab\\\\Desktop\\\\DataIntelligenceApplications\\\\')\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nfrom project.dia_pckg.Campaign import Campaign\nfrom project.dia_pckg.Class import Class\nfrom project.dia_pckg.Config import *\nfrom project.dia_pckg.User import User\nfrom project.dia_pckg.Product import Product\n# first of all we define our campaign\nfrom project.part_4.Env_4 import Env_4\nfrom project.part_4.TS_Learner import TS_Learner\n\nn_arms = 10\n\ncampaign = Campaign(max_budget=seller_max_budget,\n                    max_n_clicks=max_n_clicks)\n\n# one product to sell\nproduct = Product(name=product_name,\n                  base_price=product_base_price,\n                  max_price=product_max_price,\n                  production_cost=product_production_cost)\n\n# three classes of users:\nclass_names = list(classes.keys())\nprint('Classes:', class_names)\n\n# initialization of the three classes\nclass_1 = Class(class_name=class_names[0], class_features=classes[class_names[0]], product=product,\n                n_abrupt_phases=n_abrupts, seed=5)\nclass_2 = Class(class_name=class_names[1], class_features=classes[class_names[1]], product=product,\n                n_abrupt_phases=n_abrupts, seed=10)\nclass_3 = Class(class_name=class_names[2], class_features=classes[class_names[2]], product=product,\n                n_abrupt_phases=n_abrupts, seed=15)\n\nenv = Env_4(initial_date=initial_date,\n            n_days=n_days,\n            #users_per_day=avg_users_per_day,\n            users_per_day=1,\n            class_1=class_1,\n            class_2=class_2,\n            class_3=class_3,\n            n_arms=n_arms)\n\noptimals = env.get_optimals()\nplt.plot(env.classes[0].conv_rates[0][0], env.classes[0].conv_rates[0][1], label=class_1.name, linestyle='--')\nplt.plot(env.classes[1].conv_rates[0][0], env.classes[1].conv_rates[0][1], label=class_2.name, linestyle='--')\nplt.plot(env.classes[2].conv_rates[0][0], env.classes[2].conv_rates[0][1], label=class_3.name, linestyle='--')\nplt.plot(env.aggregate_demand_curve[0], env.aggregate_demand_curve[1], label='aggregate')\n\nplt.scatter(optimals[1][0], optimals[1][1], marker='o', label=f'opt {class_1.name}')\nplt.scatter(optimals[2][0], optimals[2][1], marker='o', label=f'opt {class_2.name}')\nplt.scatter(optimals[3][0], optimals[3][1], marker='o', label=f'opt {class_3.name}')\nplt.scatter(optimals[0][0], optimals[0][1], marker='o', label='opt aggregate')\n\nplt.xlabel('Price')\nplt.ylabel('Conversion Rate')\nplt.legend()\nplt.show()\n\n\nn_experiments = 200 # the number is small to do a raw test, otherwise set it to 1000\nrewards_per_experiment = []\narm_prices = env.get_arm_price(np.arange(n_arms))\n\nfor e in range(0, n_experiments):\n    current_date, done = env.reset()\n    ts_learner = TS_Learner(n_arms=n_arms)\n    \n    while not done:\n        #pulled_arm = ts_learner.pull_arm() #optimize by demand\n        pulled_arm = ts_learner.pull_arm_v2(arm_prices) #optimize by revenue\n        \n        user = User(random=True)\n        reward, current_date, done = env.user_step(pulled_arm, user)\n        ts_learner.update(pulled_arm, reward)\n\n    probabilities = ts_learner.collected_rewards\n    arms = ts_learner.collected_arms\n    prices = env.get_arm_price(arms)\n\n    rewards = prices * probabilities\n    rewards_per_experiment.append(rewards)\n\n\naggregate_opt = optimals[0][0] * optimals[0][1] #the optimal value is the area under demand-price\nclass1_opt = optimals[1][0] * optimals[1][1] #the optimal value is the area under demand-price\nclass2_opt = optimals[2][0] * optimals[2][1] #the optimal value is the area under demand-price\nclass3_opt = optimals[3][0] * optimals[3][1] #the optimal value is the area under demand-price\n\nplt.plot(np.cumsum(np.mean(class1_opt - rewards_per_experiment, axis=0)), label='Regret of the ' +  class_1.name + ' model' )\nplt.plot(np.cumsum(np.mean(class2_opt - rewards_per_experiment, axis=0)), label='Regret of the ' +  class_2.name + ' model' )\nplt.plot(np.cumsum(np.mean(class3_opt - rewards_per_experiment, axis=0)), label='Regret of the ' +  class_3.name + ' model' )\nplt.plot(np.cumsum(np.mean(aggregate_opt - rewards_per_experiment, axis=0)), label='Regret of the aggregate model')\nplt.xlabel('Time')\nplt.ylabel('Regret')\nplt.legend()\nplt.show()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- project/part_4/Testing_Environment.py	(revision 3faa883b1d6fa6d2d9ec3a0365c72f4cece51532)
+++ project/part_4/Testing_Environment.py	(date 1588535050751)
@@ -1,15 +1,13 @@
-import sys
-#sys.path.insert(0, 'D:\\usw-andreab\\Desktop\\DataIntelligenceApplications\\')
+# sys.path.insert(0, 'D:\\usw-andreab\\Desktop\\DataIntelligenceApplications\\')
 
 import matplotlib.pyplot as plt
 import numpy as np
 
-
 from project.dia_pckg.Campaign import Campaign
 from project.dia_pckg.Class import Class
 from project.dia_pckg.Config import *
-from project.dia_pckg.User import User
 from project.dia_pckg.Product import Product
+from project.dia_pckg.User import User
 # first of all we define our campaign
 from project.part_4.Env_4 import Env_4
 from project.part_4.TS_Learner import TS_Learner
@@ -39,7 +37,7 @@
 
 env = Env_4(initial_date=initial_date,
             n_days=n_days,
-            #users_per_day=avg_users_per_day,
+            # users_per_day=avg_users_per_day,
             users_per_day=1,
             class_1=class_1,
             class_2=class_2,
@@ -62,19 +60,18 @@
 plt.legend()
 plt.show()
 
-
-n_experiments = 200 # the number is small to do a raw test, otherwise set it to 1000
+n_experiments = 200  # the number is small to do a raw test, otherwise set it to 1000
 rewards_per_experiment = []
 arm_prices = env.get_arm_price(np.arange(n_arms))
 
 for e in range(0, n_experiments):
     current_date, done = env.reset()
     ts_learner = TS_Learner(n_arms=n_arms)
-    
+
     while not done:
-        #pulled_arm = ts_learner.pull_arm() #optimize by demand
-        pulled_arm = ts_learner.pull_arm_v2(arm_prices) #optimize by revenue
-        
+        # pulled_arm = ts_learner.pull_arm() #optimize by demand
+        pulled_arm = ts_learner.pull_arm_v2(arm_prices)  # optimize by revenue
+
         user = User(random=True)
         reward, current_date, done = env.user_step(pulled_arm, user)
         ts_learner.update(pulled_arm, reward)
@@ -86,17 +83,19 @@
     rewards = prices * probabilities
     rewards_per_experiment.append(rewards)
 
-
-aggregate_opt = optimals[0][0] * optimals[0][1] #the optimal value is the area under demand-price
-class1_opt = optimals[1][0] * optimals[1][1] #the optimal value is the area under demand-price
-class2_opt = optimals[2][0] * optimals[2][1] #the optimal value is the area under demand-price
-class3_opt = optimals[3][0] * optimals[3][1] #the optimal value is the area under demand-price
+aggregate_opt = optimals[0][0] * optimals[0][1]  # the optimal value is the area under demand-price
+class1_opt = optimals[1][0] * optimals[1][1]  # the optimal value is the area under demand-price
+class2_opt = optimals[2][0] * optimals[2][1]  # the optimal value is the area under demand-price
+class3_opt = optimals[3][0] * optimals[3][1]  # the optimal value is the area under demand-price
 
-plt.plot(np.cumsum(np.mean(class1_opt - rewards_per_experiment, axis=0)), label='Regret of the ' +  class_1.name + ' model' )
-plt.plot(np.cumsum(np.mean(class2_opt - rewards_per_experiment, axis=0)), label='Regret of the ' +  class_2.name + ' model' )
-plt.plot(np.cumsum(np.mean(class3_opt - rewards_per_experiment, axis=0)), label='Regret of the ' +  class_3.name + ' model' )
+plt.plot(np.cumsum(np.mean(class1_opt - rewards_per_experiment, axis=0)),
+         label='Regret of the ' + class_1.name + ' model')
+plt.plot(np.cumsum(np.mean(class2_opt - rewards_per_experiment, axis=0)),
+         label='Regret of the ' + class_2.name + ' model')
+plt.plot(np.cumsum(np.mean(class3_opt - rewards_per_experiment, axis=0)),
+         label='Regret of the ' + class_3.name + ' model')
 plt.plot(np.cumsum(np.mean(aggregate_opt - rewards_per_experiment, axis=0)), label='Regret of the aggregate model')
 plt.xlabel('Time')
 plt.ylabel('Regret')
 plt.legend()
-plt.show()
\ No newline at end of file
+plt.show()
Index: project/dia_pckg/Config.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>##########################################\n#             Configurations             #\n##########################################\n\n# campaign\ninitial_date = '20200101'\nn_days = 365\n\n# Seller wallet and ambitions\nseller_max_budget = 20000  # $\nmax_n_clicks = 10000\navg_users_per_day = 10  # this param must be changed after budget allocation available!\n\n# one product to sell\nproduct_name = 'shoes'\nproduct_base_price = 100\nproduct_max_price = 500\nproduct_production_cost = 0\n\n# features space\nfeatures_space = {\n    'age': ['<30', '>30'],\n    'profession': ['student', 'worker']\n}\n\n# three classes of users\nclasses = {\n    'elegant': [1, 1],  # >30, worker\n    'casual': [0, 0],  # <30, student\n    'sports': [0, 1]  # <30, worker\n}\n# number of abrupt phases\nn_abrupts = 3\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- project/dia_pckg/Config.py	(revision 3faa883b1d6fa6d2d9ec3a0365c72f4cece51532)
+++ project/dia_pckg/Config.py	(date 1588519163774)
@@ -31,4 +31,3 @@
 }
 # number of abrupt phases
 n_abrupts = 3
-
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.7 (DataIntelligenceApplications)\" project-jdk-type=\"Python SDK\" />\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision 3faa883b1d6fa6d2d9ec3a0365c72f4cece51532)
+++ .idea/misc.xml	(date 1588519000367)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.7 (DataIntelligenceApplications)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.7" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: .idea/DataIntelligenceApplications.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"PYTHON_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\">\n    <content url=\"file://$MODULE_DIR$\" />\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.7 (DataIntelligenceApplications)\" jdkType=\"Python SDK\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/DataIntelligenceApplications.iml	(revision 3faa883b1d6fa6d2d9ec3a0365c72f4cece51532)
+++ .idea/DataIntelligenceApplications.iml	(date 1588519000311)
@@ -2,7 +2,7 @@
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
     <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="Python 3.7 (DataIntelligenceApplications)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.7" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
Index: .vscode/settings.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n    \"editor.minimap.enabled\": false\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .vscode/settings.json	(revision 3faa883b1d6fa6d2d9ec3a0365c72f4cece51532)
+++ .vscode/settings.json	(date 1588519163730)
@@ -1,3 +1,3 @@
 {
-    "editor.minimap.enabled": false
+  "editor.minimap.enabled": false
 }
\ No newline at end of file
