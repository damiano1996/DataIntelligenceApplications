Index: project/part_4/Testing_Environment.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># sys.path.insert(0, 'D:\\\\usw-andreab\\\\Desktop\\\\DataIntelligenceApplications\\\\')\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom project.dia_pckg.Campaign import Campaign\nfrom project.dia_pckg.Class import Class\nfrom project.dia_pckg.Config import *\nfrom project.dia_pckg.Product import Product\nfrom project.dia_pckg.User import User\n# first of all we define our campaign\nfrom project.part_4.Env_4 import Env_4\nfrom project.part_4.TS_Learner import TS_Learner\n\nn_arms = 10\n\ncampaign = Campaign(max_budget=seller_max_budget,\n                    max_n_clicks=max_n_clicks)\n\n# one product to sell\nproduct = Product(name=product_name,\n                  base_price=product_base_price,\n                  max_price=product_max_price,\n                  production_cost=product_production_cost)\n\n# three classes of users:\nclass_names = list(classes.keys())\nprint('Classes:', class_names)\n\n# initialization of the three classes\nclass_1 = Class(class_name=class_names[0], class_features=classes[class_names[0]], product=product,\n                n_abrupt_phases=n_abrupts)\nclass_2 = Class(class_name=class_names[1], class_features=classes[class_names[1]], product=product,\n                n_abrupt_phases=n_abrupts)\nclass_3 = Class(class_name=class_names[2], class_features=classes[class_names[2]], product=product,\n                n_abrupt_phases=n_abrupts)\n\nenv = Env_4(initial_date=initial_date,\n            n_days=n_days,\n            # users_per_day=avg_users_per_day,\n            users_per_day=1,\n            class_1=class_1,\n            class_2=class_2,\n            class_3=class_3,\n            n_arms=n_arms)\n\noptimals = env.get_optimals()\nplt.plot(env.classes[0].conv_rates[0][0], env.classes[0].conv_rates[0][1], label=class_1.name, linestyle='--')\nplt.plot(env.classes[1].conv_rates[0][0], env.classes[1].conv_rates[0][1], label=class_2.name, linestyle='--')\nplt.plot(env.classes[2].conv_rates[0][0], env.classes[2].conv_rates[0][1], label=class_3.name, linestyle='--')\nplt.plot(env.aggregate_demand_curve[0], env.aggregate_demand_curve[1], label='aggregate')\n\nplt.scatter(optimals[class_1.name]['price'], optimals[class_1.name]['probability'], marker='o',\n            label=f'opt {class_1.name}')\nplt.scatter(optimals[class_2.name]['price'], optimals[class_2.name]['probability'], marker='o',\n            label=f'opt {class_2.name}')\nplt.scatter(optimals[class_3.name]['price'], optimals[class_3.name]['probability'], marker='o',\n            label=f'opt {class_3.name}')\nplt.scatter(optimals['aggregate']['price'], optimals['aggregate']['probability'], marker='o', label='opt aggregate')\n\nplt.xlabel('Price')\nplt.ylabel('Conversion Rate')\nplt.legend()\nplt.show()\n\nn_experiments = 200  # the number is small to do a raw test, otherwise set it to 1000\nrewards_per_experiment = []\narm_prices = env.get_arm_price(np.arange(n_arms))\n# print('one', arm_prices)\n\nfor e in range(0, n_experiments):\n    current_date, done = env.reset()\n    ts_learner = TS_Learner(n_arms=n_arms)\n\n    while not done:\n        # pulled_arm = ts_learner.pull_arm() #optimize by demand\n        pulled_arm = ts_learner.pull_arm_v2(arm_prices)  # optimize by revenue\n\n        user = User(random=True)\n        reward, current_date, done = env.user_step(pulled_arm, user)\n        ts_learner.update(pulled_arm, reward)\n\n    probabilities = ts_learner.collected_rewards\n    arms = ts_learner.collected_arms\n    prices = env.get_arm_price(arms)\n    # print('two', prices)\n\n    rewards = prices * probabilities\n    rewards_per_experiment.append(rewards)\n\naggregate_opt = optimals['aggregate']['price'] * optimals['aggregate'][\n    'probability']  # the optimal value is the area under demand-price\nclass1_opt = optimals[class_1.name]['price'] * optimals[class_1.name][\n    'probability']  # the optimal value is the area under demand-price\nclass2_opt = optimals[class_2.name]['price'] * optimals[class_2.name][\n    'probability']  # the optimal value is the area under demand-price\nclass3_opt = optimals[class_3.name]['price'] * optimals[class_3.name][\n    'probability']  # the optimal value is the area under demand-price\n\nplt.plot(np.cumsum(np.mean(class1_opt - rewards_per_experiment, axis=0)),\n         label='Regret of the ' + class_1.name + ' model')\nplt.plot(np.cumsum(np.mean(class2_opt - rewards_per_experiment, axis=0)),\n         label='Regret of the ' + class_2.name + ' model')\nplt.plot(np.cumsum(np.mean(class3_opt - rewards_per_experiment, axis=0)),\n         label='Regret of the ' + class_3.name + ' model')\nplt.plot(np.cumsum(np.mean(aggregate_opt - rewards_per_experiment, axis=0)), label='Regret of the aggregate model')\nplt.xlabel('Time')\nplt.ylabel('Regret')\nplt.legend()\nplt.show()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- project/part_4/Testing_Environment.py	(revision e02afd5f6df4089358c009872eeb8b2f770a8023)
+++ project/part_4/Testing_Environment.py	(date 1588590298025)
@@ -1,5 +1,3 @@
-# sys.path.insert(0, 'D:\\usw-andreab\\Desktop\\DataIntelligenceApplications\\')
-
 import matplotlib.pyplot as plt
 import numpy as np
 
@@ -12,6 +10,8 @@
 from project.part_4.Env_4 import Env_4
 from project.part_4.TS_Learner import TS_Learner
 
+np.random.seed(0)
+
 n_arms = 10
 
 campaign = Campaign(max_budget=seller_max_budget,
@@ -66,7 +66,6 @@
 n_experiments = 200  # the number is small to do a raw test, otherwise set it to 1000
 rewards_per_experiment = []
 arm_prices = env.get_arm_price(np.arange(n_arms))
-# print('one', arm_prices)
 
 for e in range(0, n_experiments):
     current_date, done = env.reset()
@@ -83,7 +82,6 @@
     probabilities = ts_learner.collected_rewards
     arms = ts_learner.collected_arms
     prices = env.get_arm_price(arms)
-    # print('two', prices)
 
     rewards = prices * probabilities
     rewards_per_experiment.append(rewards)
